# ========================================
# ZSH Configuration for WSL
# ========================================

# ---- Performance: Lazy Completion Init ----
# Load completion system lazily for faster startup
autoload -Uz compinit
# Only regenerate completion cache once a day
if [[ -n "${ZDOTDIR}/.zcompdump(#qN.mh+24)" ]]; then
    compinit
else
    compinit -C
fi

# ---- Shell Options ----
# Directory navigation
setopt AUTO_CD              # cd by typing directory name
setopt AUTO_PUSHD           # Make cd push old directory onto stack
setopt PUSHD_IGNORE_DUPS    # Don't push duplicates
setopt PUSHD_SILENT         # Don't print directory stack
setopt CDABLE_VARS          # cd to path stored in variable

# Globbing
setopt EXTENDED_GLOB        # Extended globbing (^, ~, #)
setopt GLOB_DOTS            # Include dotfiles in glob
setopt NOMATCH              # Print error if pattern has no matches

# General
setopt INTERACTIVE_COMMENTS # Allow comments in interactive shell
setopt NOTIFY               # Report bg job status immediately
setopt NO_BEEP              # Disable beep

# ---- History Configuration ----
HISTFILE=~/.zsh_history
HISTSIZE=50000
SAVEHIST=50000

setopt EXTENDED_HISTORY          # Write timestamp to history
setopt INC_APPEND_HISTORY        # Write immediately, not on exit
setopt SHARE_HISTORY             # Share history across terminals
setopt HIST_EXPIRE_DUPS_FIRST    # Expire duplicates first
setopt HIST_IGNORE_DUPS          # Don't record duplicates
setopt HIST_IGNORE_ALL_DUPS      # Delete old duplicate entries
setopt HIST_FIND_NO_DUPS         # Don't display duplicates in search
setopt HIST_IGNORE_SPACE         # Ignore commands starting with space
setopt HIST_SAVE_NO_DUPS         # Don't write duplicate entries
setopt HIST_REDUCE_BLANKS        # Remove superfluous blanks
setopt HIST_VERIFY               # Show command before executing from history

# ---- Environment Variables ----
export EDITOR='nano'
export VISUAL='nano'
export PAGER='less'

# Better colors for less/man pages
export LESS='-R -M -i -j10'
export LESS_TERMCAP_mb=$'\e[1;31m'     # begin bold
export LESS_TERMCAP_md=$'\e[1;36m'     # begin blink
export LESS_TERMCAP_me=$'\e[0m'        # reset bold/blink
export LESS_TERMCAP_so=$'\e[01;44;33m' # begin reverse video
export LESS_TERMCAP_se=$'\e[0m'        # reset reverse video
export LESS_TERMCAP_us=$'\e[1;32m'     # begin underline
export LESS_TERMCAP_ue=$'\e[0m'        # reset underline

# ---- Paths ----
# Helper function to add to PATH only if directory exists and not already in PATH
path_append() {
    if [[ -d "$1" ]] && [[ ":$PATH:" != *":$1:"* ]]; then
        export PATH="$PATH:$1"
    fi
}

path_prepend() {
    if [[ -d "$1" ]] && [[ ":$PATH:" != *":$1:"* ]]; then
        export PATH="$1:$PATH"
    fi
}

# Add paths in order of precedence
path_prepend "$HOME/.local/bin"
path_append "$HOME/go/bin"

# pnpm
export PNPM_HOME="$HOME/.local/share/pnpm"
path_prepend "$PNPM_HOME"

# Bun
export BUN_INSTALL="$HOME/.bun"
path_prepend "$BUN_INSTALL/bin"

# Deno
export DENO_INSTALL="$HOME/.deno"
path_prepend "$DENO_INSTALL/bin"

# uv (Python)
path_append "$HOME/.local/share/uv/bin"

# OpenCode
path_prepend "$HOME/.opencode/bin"

# Cargo (Rust)
path_append "$HOME/.cargo/bin"

# ---- Keybindings ----
# Use emacs keybindings
bindkey -e

# Basic navigation
bindkey '\e[2~' overwrite-mode              # Insert
bindkey '\e[3~' delete-char                 # Delete
bindkey '\e[1~' beginning-of-line           # Home
bindkey '\e[4~' end-of-line                 # End
bindkey '\e[H' beginning-of-line            # Home (alt)
bindkey '\e[F' end-of-line                  # End (alt)
bindkey '\e[5~' beginning-of-history        # Page Up
bindkey '\e[6~' end-of-history              # Page Down

# Ctrl + arrow keys for word-by-word navigation (Windows-style)
_forward_word_windows() {
    local WORDCHARS_OLD=$WORDCHARS
    WORDCHARS='*?[]~=&;!#$%^(){}<>'
    zle .forward-word
    WORDCHARS=$WORDCHARS_OLD
}
zle -N _forward_word_windows

_backward_word_windows() {
    local WORDCHARS_OLD=$WORDCHARS
    WORDCHARS='*?[]~=&;!#$%^(){}<>'
    zle .backward-word
    WORDCHARS=$WORDCHARS_OLD
}
zle -N _backward_word_windows

bindkey '\e[1;5C' _forward_word_windows     # Ctrl+Right
bindkey '\e[1;5D' _backward_word_windows    # Ctrl+Left

# Alt+D: Delete word forward
bindkey '\ed' kill-word

# Ctrl+W: Delete word backward (with region support)
_backward_kill_word_or_region() {
    if ((REGION_ACTIVE)); then
        zle kill-region
    else
        zle backward-kill-word
    fi
}
zle -N _backward_kill_word_or_region
bindkey '^W' _backward_kill_word_or_region

# Ctrl+K: Kill to end of line (with region support)
_kill_line_or_region() {
    if ((REGION_ACTIVE)); then
        zle kill-region
    else
        zle kill-line
    fi
}
zle -N _kill_line_or_region
bindkey '^K' _kill_line_or_region

# Ctrl+U: Kill to beginning of line (with region support)
_backward_kill_line_or_region() {
    if ((REGION_ACTIVE)); then
        zle kill-region
    else
        zle backward-kill-line
    fi
}
zle -N _backward_kill_line_or_region
bindkey '^U' _backward_kill_line_or_region

# Ctrl+Z: Undo
bindkey '^Z' undo

# Ctrl+Y: Redo (yank)
bindkey '^Y' redo

# Shift + arrow keys for character selection
_shift_select_forward() {
    if ((REGION_ACTIVE)); then
        zle .forward-char
    else
        zle .set-mark-command && zle .forward-char
    fi
}
zle -N _shift_select_forward

_shift_select_backward() {
    if ((REGION_ACTIVE)); then
        zle .backward-char
    else
        zle .set-mark-command && zle .backward-char
    fi
}
zle -N _shift_select_backward

bindkey '\e[1;2C' _shift_select_forward     # Shift+Right
bindkey '\e[1;2D' _shift_select_backward    # Shift+Left

# Ctrl + Shift + arrow keys for word selection (Windows-style)
_shift_select_forward_word() {
    if ((REGION_ACTIVE)); then
        local WORDCHARS_OLD=$WORDCHARS
        WORDCHARS='*?_[]~=&;!#$%^(){}<>'
        zle .forward-word
        WORDCHARS=$WORDCHARS_OLD
    else
        zle .set-mark-command
        local WORDCHARS_OLD=$WORDCHARS
        WORDCHARS='*?_[]~=&;!#$%^(){}<>'
        zle .forward-word
        WORDCHARS=$WORDCHARS_OLD
    fi
}
zle -N _shift_select_forward_word

_shift_select_backward_word() {
    if ((REGION_ACTIVE)); then
        local WORDCHARS_OLD=$WORDCHARS
        WORDCHARS='*?_[]~=&;!#$%^(){}<>'
        zle .backward-word
        WORDCHARS=$WORDCHARS_OLD
    else
        zle .set-mark-command
        local WORDCHARS_OLD=$WORDCHARS
        WORDCHARS='*?_[]~=&;!#$%^(){}<>'
        zle .backward-word
        WORDCHARS=$WORDCHARS_OLD
    fi
}
zle -N _shift_select_backward_word

bindkey '\e[1;6C' _shift_select_forward_word    # Ctrl+Shift+Right
bindkey '\e[1;6D' _shift_select_backward_word   # Ctrl+Shift+Left

# Shift + Home/End for line selection
_shift_select_to_start() {
    if ((REGION_ACTIVE)); then
        zle .beginning-of-line
    else
        zle .set-mark-command && zle .beginning-of-line
    fi
}
zle -N _shift_select_to_start

_shift_select_to_end() {
    if ((REGION_ACTIVE)); then
        zle .end-of-line
    else
        zle .set-mark-command && zle .end-of-line
    fi
}
zle -N _shift_select_to_end

bindkey '\e[1;2H' _shift_select_to_start    # Shift+Home
bindkey '\e[1;2F' _shift_select_to_end      # Shift+End

# Ctrl + Home/End for start/end of buffer
bindkey '\e[1;5H' beginning-of-buffer       # Ctrl+Home
bindkey '\e[1;5F' end-of-buffer             # Ctrl+End

# Ctrl + Shift + Home/End for buffer selection
_shift_select_to_start_buffer() {
    if ((REGION_ACTIVE)); then
        zle .beginning-of-buffer
    else
        zle .set-mark-command && zle .beginning-of-buffer
    fi
}
zle -N _shift_select_to_start_buffer

_shift_select_to_end_buffer() {
    if ((REGION_ACTIVE)); then
        zle .end-of-buffer
    else
        zle .set-mark-command && zle .end-of-buffer
    fi
}
zle -N _shift_select_to_end_buffer

bindkey '\e[1;6H' _shift_select_to_start_buffer # Ctrl+Shift+Home
bindkey '\e[1;6F' _shift_select_to_end_buffer   # Ctrl+Shift+End

# Ctrl+C: Copy selection to clipboard (OSC 52)
_copy_region() {
    if ((REGION_ACTIVE)); then
        zle copy-region-as-kill
        echo -n "\033]52;c;$(base64 <<< $CUTBUFFER)\a"
        zle -M "Copied to clipboard"
    fi
}
zle -N _copy_region
bindkey '^C' _copy_region

# Ctrl+X: Cut selection
_cut_region() {
    if ((REGION_ACTIVE)); then
        zle kill-region
        echo -n "\033]52;c;$(base64 <<< $CUTBUFFER)\a"
        zle -M "Cut to clipboard"
    else
        zle kill-line
    fi
}
zle -N _cut_region
bindkey '^X' _cut_region

# Ctrl+V: Paste (if using OSC 52 paste or just use yank)
bindkey '^V' yank

# Ctrl+A: Select all
_select_all() {
    zle beginning-of-buffer
    zle set-mark-command
    zle end-of-buffer
}
zle -N _select_all
bindkey '^A' _select_all

# Delete key to delete selection
_delete_region() {
    if ((REGION_ACTIVE)); then
        zle kill-region
    else
        zle delete-char
    fi
}
zle -N _delete_region
bindkey '\e[3~' _delete_region

# Backspace to delete selection
_backward_delete_region() {
    if ((REGION_ACTIVE)); then
        zle kill-region
    else
        zle backward-delete-char
    fi
}
zle -N _backward_delete_region
bindkey '^?' _backward_delete_region

# ---- Completion Configuration ----
zstyle ':completion:*' menu select                          # Interactive menu
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'  # Case insensitive
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"    # Colored completion
zstyle ':completion:*' group-name ''                        # Group by category
zstyle ':completion:*' verbose yes
zstyle ':completion:*:descriptions' format '%F{yellow}-- %d --%f'
zstyle ':completion:*:messages' format '%F{purple}-- %d --%f'
zstyle ':completion:*:warnings' format '%F{red}-- no matches found --%f'
zstyle ':completion:*:corrections' format '%F{green}-- %d (errors: %e) --%f'

# Cache completion for better performance
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path ~/.zsh/cache

# Better completion for specific commands
zstyle ':completion:*:*:docker:*' option-stacking yes
zstyle ':completion:*:*:docker-*:*' option-stacking yes
zstyle ':completion:*:*:git:*' script ~/.nix-profile/share/git/contrib/completion/git-completion.zsh 2>/dev/null

# ---- Aliases ----
# System
alias cls='clear'
alias editor='zed --wait'
alias EDITOR='zed --wait'
alias reload='source ~/.zshrc'
alias zshconfig='$EDITOR ~/.zshrc'
alias explorer='/mnt/c/WINDOWS/explorer.exe'
alias vim='nvim'

# Navigation shortcuts
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias -- -='cd -'  # Go to previous directory

# Eza (modern ls replacement)
alias l='eza --color=always --long --git --no-filesize --icons=always'
alias ls='eza --color=always --long --git --no-filesize --icons=always --all --color-scale-mode=gradient'
alias la='eza --color=always --long --git --icons=always --all --group-directories-first'
alias ll='eza --color=always --long --git --icons=always --header --group-directories-first'
alias lt='eza --color=always --long --git --icons=always --tree --level=2'
alias lta='eza --color=always --long --git --icons=always --tree --level=2 --all'

# Python/uv
if command -v uv &> /dev/null; then
    alias pip='uv pip'
    alias python='uv run python'
    alias py='uv run python'
fi

# cf dev
alias wrangler="bun wrangler"

# Home Manager and system updates
hm-sync() {
    echo "Syncing Home Manager configuration from GitHub..."
    (set -o noglob; home-manager switch --flake 'github:jfalava/outfitting?dir=packages/x64-linux#jfalava' --no-write-lock-file "$@")
}

wsl-update() {
    curl -L https://wsl.jfa.dev | bash -s -- --update-only
}

# Misc tools
alias ff='fastfetch'
alias cat='bat --style=auto' 2>/dev/null || alias cat='cat'  # Use bat if available
alias diff='diff --color=auto'
alias -s ts='bun'

# Ripgrep (preferred over grep)
if command -v rg &> /dev/null; then
    alias grep='rg'
    alias rgi='rg -i'                          # Case insensitive
    alias rgl='rg --files-with-matches'        # Only show filenames
    alias rgc='rg --count'                     # Count matches per file
    alias rgh='rg --hidden'                    # Include hidden files
    alias rgz='rg -z'                          # Search in compressed files
    alias rgt='rg --type-list'                 # Show supported file types
    alias rgpy='rg --type py'                  # Python files only
    alias rgjs='rg --type js'                  # JavaScript files only
    alias rgts='rg --type ts'                  # TypeScript files only
    alias rggo='rg --type go'                  # Go files only
    alias rgrs='rg --type rust'                # Rust files only
else
    alias grep='grep --color=auto'
fi

# ---- Functions ----

# Smart cd that also lists contents
unalias cd 2>/dev/null || true
cd() {
    builtin cd "$@" && ls
}

# Create directory and cd into it
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Extract any archive
extract() {
    if [ -f "$1" ]; then
        case "$1" in
            *.tar.bz2)   tar xjf "$1"     ;;
            *.tar.gz)    tar xzf "$1"     ;;
            *.bz2)       bunzip2 "$1"     ;;
            *.rar)       unrar x "$1"     ;;
            *.gz)        gunzip "$1"      ;;
            *.tar)       tar xf "$1"      ;;
            *.tbz2)      tar xjf "$1"     ;;
            *.tgz)       tar xzf "$1"     ;;
            *.zip)       unzip "$1"       ;;
            *.Z)         uncompress "$1"  ;;
            *.7z)        7z x "$1"        ;;
            *.tar.xz)    tar xf "$1"      ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Find process using a port
port() {
    if [ -z "$1" ]; then
        echo "Usage: port <port_number>"
        return 1
    fi
    sudo lsof -i ":$1" || sudo ss -tulpn | grep ":$1"
}

# Quick weather
weather() {
    local location="${1:-}"
    curl -s "wttr.in/${location}?format=3"
}

# Git: Quick commit all
gac() {
    git add --all && git commit -m "$*"
}

# Git: Quick push
gacp() {
    git add --all && git commit -m "$*" && git push
}

# Docker: Enter running container
denter() {
    if [ -z "$1" ]; then
        echo "Usage: denter <container_name_or_id>"
        return 1
    fi
    docker exec -it "$1" /bin/bash || docker exec -it "$1" /bin/sh
}

# Docker: Stop all containers
dstop() {
    docker stop $(docker ps -q)
}

# Home Manager management functions
hm-switch() {
    echo "Applying Home Manager configuration from GitHub..."
    home-manager switch --flake "github:jfalava/outfitting?dir=packages/x64-linux#jfalava"
}

hm-switch-local() {
    if [ ! -d "$HOME/Workspace/outfitting" ]; then
        echo "Error: ~/Workspace/outfitting not found."
        echo ""
        echo "To use local development workflow:"
        echo "  1. Clone the repo:"
        echo "     git clone https://github.com/jfalava/outfitting.git ~/Workspace/outfitting"
        echo "  2. Make changes to ~/Workspace/outfitting/packages/x64-linux/home.nix"
        echo "  3. Run: hm-switch-local"
        echo "  4. Commit and push changes (including flake.lock)"
        return 1
    fi

    echo "Applying Home Manager configuration from local repo..."
    home-manager switch --flake "$HOME/Workspace/outfitting/packages/x64-linux#jfalava"

    # Check if there are uncommitted changes
    if git -C "$HOME/Workspace/outfitting" diff --quiet && git -C "$HOME/Workspace/outfitting" diff --cached --quiet; then
        echo ""
        echo "✓ No uncommitted changes - you're all set!"
    else
        echo ""
        echo "⚠ You have uncommitted changes in ~/Workspace/outfitting"
        echo "  Don't forget to commit and push to sync across machines:"
        echo "    cd ~/Workspace/outfitting"
        echo "    git add packages/x64-linux/home.nix packages/x64-linux/flake.lock"
        echo "    git commit -m 'Update home-manager config'"
        echo "    git push"
    fi
}

hm-update() {
    echo "Updating flake inputs and switching..."
    home-manager switch --flake "github:jfalava/outfitting?dir=packages/x64-linux#jfalava" --recreate-lock-file
}

hm-rollback() {
    echo "Available generations:"
    home-manager generations
    echo ""
    echo "To rollback, run the activation script of your desired generation (listed above)"
}

hm-clean() {
    echo "Cleaning old Home Manager generations..."
    nix-collect-garbage -d
    echo "Cleaning complete!"
}


# Nix management functions (legacy - now use Home Manager)
nix-search() {
    nix search nixpkgs "$1"
}

# System update
update-all() {
    echo "Updating APT packages..."
    sudo apt update && sudo apt upgrade -y && sudo apt autoremove -y

    echo -e "\nUpdating Home Manager configuration..."
    hm-update

    echo -e "\nCleaning old generations..."
    hm-clean

    echo -e "\nUpdating global npm packages..."
    if command -v pnpm &> /dev/null; then
        pnpm update -g
    fi

    echo -e "\nUpdate complete!"
}

# Show directory size sorted
dirsize() {
    du -sh */ 2>/dev/null | sort -h
}

# Backup file with timestamp
backup() {
    if [ -z "$1" ]; then
        echo "Usage: backup <file>"
        return 1
    fi
    cp "$1" "${1}.backup.$(date +%Y%m%d_%H%M%S)"
}

# Outfitting dotfile update functions (now managed by Home Manager)
update-dotfiles() {
    echo "Dotfiles are now managed by Home Manager!"
    echo "To update dotfiles:"
    echo "  1. Edit files in ~/Workspace/outfitting/dotfiles/"
    echo "  2. Commit changes: git add . && git commit"
    echo "  3. Run: hm-sync"
    echo ""
    echo "Or run 'hm-sync' to pull latest from GitHub"
}

update-zshrc() {
    echo ".zshrc is now managed by Home Manager!"
    echo "To update:"
    echo "  1. Edit ~/Workspace/outfitting/dotfiles/.zshrc-wsl"
    echo "  2. Run: hm-switch-local  (or commit & hm-sync)"
    echo "  3. Reload: source ~/.zshrc"
}

update-ripgreprc() {
    echo ".ripgreprc is now managed by Home Manager!"
    echo "To update:"
    echo "  1. Edit ~/Workspace/outfitting/dotfiles/.ripgreprc"
    echo "  2. Run: hm-switch-local  (or commit & hm-sync)"
}

# Ripgrep functions
if command -v rg &> /dev/null; then
    # Search and edit results in editor
    rge() {
        if [ -z "$1" ]; then
            echo "Usage: rge <pattern> [path]"
            return 1
        fi
        local files=$(rg --files-with-matches "$1" "${2:-.}")
        if [ -n "$files" ]; then
            echo "$files" | xargs $EDITOR
        else
            echo "No matches found"
        fi
    }

    # Search with context (5 lines before/after)
    rgx() {
        rg --context 5 "$@"
    }

    # Search for TODO/FIXME/XXX/HACK comments
    todos() {
        rg --heading --line-number --color=always \
            "TODO|FIXME|XXX|HACK|BUG|NOTE" "${1:-.}"
    }

    # Search for function/class definitions
    rgfunc() {
        if [ -z "$1" ]; then
            echo "Usage: rgfunc <function_name> [path]"
            return 1
        fi
        rg --heading --line-number \
            "(function|def|class|fn|func|const|let|var)\s+$1" \
            "${2:-.}"
    }

    # Search with stats (count + files)
    rgstats() {
        if [ -z "$1" ]; then
            echo "Usage: rgstats <pattern> [path]"
            return 1
        fi
        echo "=== Match Statistics ==="
        rg --count --heading "$1" "${2:-.}"
        echo ""
        echo "=== Total Matches ==="
        rg --count-matches "$1" "${2:-.}" | awk -F: '{sum+=$2} END {print sum " total matches"}'
    }
fi

# ---- Plugin Loading ----
# Load plugins from nix-profile
if [ -f $HOME/.nix-profile/share/zsh-autosuggestions/zsh-autosuggestions.zsh ]; then
    source $HOME/.nix-profile/share/zsh-autosuggestions/zsh-autosuggestions.zsh
    ZSH_AUTOSUGGEST_STRATEGY=(history completion)
    ZSH_AUTOSUGGEST_BUFFER_MAX_SIZE=20
fi

# Syntax highlighting must be loaded last
if [ -f $HOME/.nix-profile/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]; then
    source $HOME/.nix-profile/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
    # Customize colors
    ZSH_HIGHLIGHT_STYLES[command]='fg=green,bold'
    ZSH_HIGHLIGHT_STYLES[alias]='fg=cyan,bold'
    ZSH_HIGHLIGHT_STYLES[builtin]='fg=yellow,bold'
    ZSH_HIGHLIGHT_STYLES[function]='fg=blue,bold'
fi

# ---- Tool Initialization ----
# Nix - Try daemon first (multi-user), then single-user profile
if [ -e /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh ]; then
    source /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh
elif [ -e ~/.nix-profile/etc/profile.d/nix.sh ]; then
    source ~/.nix-profile/etc/profile.d/nix.sh
fi

# Zoxide (smart cd)
if command -v zoxide &> /dev/null; then
    eval "$(zoxide init zsh)"
fi

# FZF (fuzzy finder)
if command -v fzf &> /dev/null; then
    # FZF default options
    export FZF_DEFAULT_OPTS='
        --height 40%
        --layout=reverse
        --border
        --inline-info
        --color=fg:#f8f8f2,bg:#282a36,hl:#bd93f9
        --color=fg+:#f8f8f2,bg+:#44475a,hl+:#bd93f9
        --color=info:#ffb86c,prompt:#50fa7b,pointer:#ff79c6
        --color=marker:#ff79c6,spinner:#ffb86c,header:#6272a4'

    # Use fd for file listing if available
    if command -v fd &> /dev/null; then
        export FZF_DEFAULT_COMMAND='fd --type f --hidden --follow --exclude .git'
        export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
        export FZF_ALT_C_COMMAND='fd --type d --hidden --follow --exclude .git'
    fi

    # Load FZF keybindings
    source <(fzf --zsh) 2>/dev/null
fi

# SSH Agent - Persistent across shell sessions
SSH_AGENT_FILE="$HOME/.ssh/agent-env"

if [ -f "$SSH_AGENT_FILE" ]; then
    eval "$(cat "$SSH_AGENT_FILE")" > /dev/null 2>&1
fi

if [ -z "$SSH_AUTH_SOCK" ] || [ ! -S "$SSH_AUTH_SOCK" ]; then
    ssh_agent_output="$(ssh-agent -s)"
    echo "$ssh_agent_output" > "$SSH_AGENT_FILE"
    eval "$ssh_agent_output" > /dev/null 2>&1
    chmod 600 "$SSH_AGENT_FILE"
fi

unset SSH_AGENT_FILE

# Starship prompt (must be near the end)
if command -v starship &> /dev/null; then
    eval "$(starship init zsh)"
fi

# Keyring daemons (for credential storage)
if ! pgrep -f "dbus-daemon" > /dev/null 2>&1; then
    dbus-daemon --session --fork 2>/dev/null
fi

if ! pgrep -f "gnome-keyring-daemon" > /dev/null 2>&1; then
    gnome-keyring-daemon --start --components=secrets 2>/dev/null
fi

# ---- Bun Completions ----
if command -v bun &> /dev/null; then
    [ -s "$HOME/.bun/_bun" ] && source "$HOME/.bun/_bun"
fi
